import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/dnd-core/lib/cjs/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/dnd-core/lib/cjs/interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HandlerRole;
    (function(HandlerRole2) {
      HandlerRole2["SOURCE"] = "SOURCE";
      HandlerRole2["TARGET"] = "TARGET";
    })(HandlerRole = exports.HandlerRole || (exports.HandlerRole = {}));
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var init_objectSpread2 = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectSpread2.js"() {
    init_defineProperty();
  }
});

// node_modules/redux/es/redux.js
var redux_exports = {};
__export(redux_exports, {
  __DO_NOT_USE__ActionTypes: () => ActionTypes,
  applyMiddleware: () => applyMiddleware,
  bindActionCreators: () => bindActionCreators,
  combineReducers: () => combineReducers,
  compose: () => compose,
  createStore: () => createStore,
  legacy_createStore: () => legacy_createStore
});
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function miniKindOf(val) {
  if (val === void 0) return "undefined";
  if (val === null) return "null";
  var type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val)) return "array";
  if (isDate(val)) return "date";
  if (isError(val)) return "error";
  var constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  var typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }
  var unexpectedKeys = Object.keys(inputState).filter(function(key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function(key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;
  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer = reducers[key];
    var initialState = reducer(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error(false ? formatProdErrorMessage(12) : 'The slice reducer for key "' + key + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(false ? formatProdErrorMessage(13) : 'The slice reducer for key "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle '" + ActionTypes.INIT + `' or other actions in "redux/*" `) + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];
    if (true) {
      if (typeof reducers[key] === "undefined") {
        warning('No reducer provided for key "' + key + '"');
      }
    }
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var unexpectedKeyCache;
  if (true) {
    unexpectedKeyCache = {};
  }
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        var actionType = action && action.type;
        throw new Error(false ? formatProdErrorMessage(14) : "When called with an action of type " + (actionType ? '"' + String(actionType) + '"' : "(unknown type)") + ', the slice reducer for key "' + _key + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.');
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(false ? formatProdErrorMessage(16) : "bindActionCreators expected an object or a function, but instead received: '" + kindOf(actionCreators) + `'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a, b) {
    return function() {
      return a(b.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}
var $$observable, randomString, ActionTypes, legacy_createStore;
var init_redux = __esm({
  "node_modules/redux/es/redux.js"() {
    init_objectSpread2();
    $$observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    randomString = function randomString2() {
      return Math.random().toString(36).substring(7).split("").join(".");
    };
    ActionTypes = {
      INIT: "@@redux/INIT" + randomString(),
      REPLACE: "@@redux/REPLACE" + randomString(),
      PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
      }
    };
    legacy_createStore = createStore;
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/types.js
var require_types = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.INIT_COORDS = "dnd-core/INIT_COORDS";
    exports.BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
    exports.PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
    exports.HOVER = "dnd-core/HOVER";
    exports.DROP = "dnd-core/DROP";
    exports.END_DRAG = "dnd-core/END_DRAG";
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/local/setClientOffset.js
var require_setClientOffset = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/local/setClientOffset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    function setClientOffset(clientOffset, sourceClientOffset) {
      return {
        type: types_1.INIT_COORDS,
        payload: {
          sourceClientOffset: sourceClientOffset || null,
          clientOffset: clientOffset || null
        }
      };
    }
    exports.setClientOffset = setClientOffset;
  }
});

// node_modules/dnd-core/lib/cjs/utils/discount_lodash.js
var require_discount_lodash = __commonJS({
  "node_modules/dnd-core/lib/cjs/utils/discount_lodash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function get(obj, path, defaultValue) {
      return path.split(".").reduce(function(a, c) {
        return a && a[c] ? a[c] : defaultValue || null;
      }, obj);
    }
    exports.get = get;
    function without(items, item) {
      return items.filter(function(i) {
        return i !== item;
      });
    }
    exports.without = without;
    function isString(input) {
      return typeof input === "string";
    }
    exports.isString = isString;
    function isObject(input) {
      return typeof input === "object";
    }
    exports.isObject = isObject;
    function xor(itemsA, itemsB) {
      var map = /* @__PURE__ */ new Map();
      var insertItem = function(item) {
        return map.set(item, map.has(item) ? map.get(item) + 1 : 1);
      };
      itemsA.forEach(insertItem);
      itemsB.forEach(insertItem);
      var result = [];
      map.forEach(function(count, key) {
        if (count === 1) {
          result.push(key);
        }
      });
      return result;
    }
    exports.xor = xor;
    function intersection(itemsA, itemsB) {
      return itemsA.filter(function(t) {
        return itemsB.indexOf(t) > -1;
      });
    }
    exports.intersection = intersection;
  }
});

// node_modules/invariant/browser.js
var require_browser = __commonJS({
  "node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/beginDrag.js
var require_beginDrag = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/beginDrag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var setClientOffset_1 = require_setClientOffset();
    var discount_lodash_1 = require_discount_lodash();
    var invariant = require_browser();
    var types_1 = require_types();
    var ResetCoordinatesAction = {
      type: types_1.INIT_COORDS,
      payload: {
        clientOffset: null,
        sourceClientOffset: null
      }
    };
    function createBeginDrag(manager) {
      return function beginDrag(sourceIds, options) {
        if (sourceIds === void 0) {
          sourceIds = [];
        }
        if (options === void 0) {
          options = {
            publishSource: true
          };
        }
        var _a = options.publishSource, publishSource = _a === void 0 ? true : _a, clientOffset = options.clientOffset, getSourceClientOffset = options.getSourceClientOffset;
        var monitor = manager.getMonitor();
        var registry = manager.getRegistry();
        manager.dispatch(setClientOffset_1.setClientOffset(clientOffset));
        verifyInvariants(sourceIds, monitor, registry);
        var sourceId = getDraggableSource(sourceIds, monitor);
        if (sourceId === null) {
          manager.dispatch(ResetCoordinatesAction);
          return;
        }
        var sourceClientOffset = null;
        if (clientOffset) {
          verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);
          sourceClientOffset = getSourceClientOffset(sourceId);
        }
        manager.dispatch(setClientOffset_1.setClientOffset(clientOffset, sourceClientOffset));
        var source = registry.getSource(sourceId);
        var item = source.beginDrag(monitor, sourceId);
        verifyItemIsObject(item);
        registry.pinSource(sourceId);
        var itemType = registry.getSourceType(sourceId);
        return {
          type: types_1.BEGIN_DRAG,
          payload: {
            itemType,
            item,
            sourceId,
            clientOffset: clientOffset || null,
            sourceClientOffset: sourceClientOffset || null,
            isSourcePublic: !!publishSource
          }
        };
      };
    }
    exports.default = createBeginDrag;
    function verifyInvariants(sourceIds, monitor, registry) {
      invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
      for (var _i = 0, sourceIds_1 = sourceIds; _i < sourceIds_1.length; _i++) {
        var s = sourceIds_1[_i];
        invariant(registry.getSource(s), "Expected sourceIds to be registered.");
      }
    }
    function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {
      invariant(typeof getSourceClientOffset === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
    }
    function verifyItemIsObject(item) {
      invariant(discount_lodash_1.isObject(item), "Item must be an object.");
    }
    function getDraggableSource(sourceIds, monitor) {
      var sourceId = null;
      for (var i = sourceIds.length - 1; i >= 0; i--) {
        if (monitor.canDragSource(sourceIds[i])) {
          sourceId = sourceIds[i];
          break;
        }
      }
      return sourceId;
    }
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/publishDragSource.js
var require_publishDragSource = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/publishDragSource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    function createPublishDragSource(manager) {
      return function publishDragSource() {
        var monitor = manager.getMonitor();
        if (monitor.isDragging()) {
          return { type: types_1.PUBLISH_DRAG_SOURCE };
        }
      };
    }
    exports.default = createPublishDragSource;
  }
});

// node_modules/dnd-core/lib/cjs/utils/matchesType.js
var require_matchesType = __commonJS({
  "node_modules/dnd-core/lib/cjs/utils/matchesType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function matchesType(targetType, draggedItemType) {
      if (draggedItemType === null) {
        return targetType === null;
      }
      return Array.isArray(targetType) ? targetType.some(function(t) {
        return t === draggedItemType;
      }) : targetType === draggedItemType;
    }
    exports.default = matchesType;
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/hover.js
var require_hover = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/hover.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matchesType_1 = require_matchesType();
    var types_1 = require_types();
    var invariant = require_browser();
    function createHover(manager) {
      return function hover(targetIdsArg, _a) {
        var clientOffset = (_a === void 0 ? {} : _a).clientOffset;
        verifyTargetIdsIsArray(targetIdsArg);
        var targetIds = targetIdsArg.slice(0);
        var monitor = manager.getMonitor();
        var registry = manager.getRegistry();
        checkInvariants(targetIds, monitor, registry);
        var draggedItemType = monitor.getItemType();
        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
        hoverAllTargets(targetIds, monitor, registry);
        return {
          type: types_1.HOVER,
          payload: {
            targetIds,
            clientOffset: clientOffset || null
          }
        };
      };
    }
    exports.default = createHover;
    function verifyTargetIdsIsArray(targetIdsArg) {
      invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
    }
    function checkInvariants(targetIds, monitor, registry) {
      invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
      invariant(!monitor.didDrop(), "Cannot call hover after drop.");
      for (var i = 0; i < targetIds.length; i++) {
        var targetId = targetIds[i];
        invariant(targetIds.lastIndexOf(targetId) === i, "Expected targetIds to be unique in the passed array.");
        var target = registry.getTarget(targetId);
        invariant(target, "Expected targetIds to be registered.");
      }
    }
    function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
      for (var i = targetIds.length - 1; i >= 0; i--) {
        var targetId = targetIds[i];
        var targetType = registry.getTargetType(targetId);
        if (!matchesType_1.default(targetType, draggedItemType)) {
          targetIds.splice(i, 1);
        }
      }
    }
    function hoverAllTargets(targetIds, monitor, registry) {
      for (var _i = 0, targetIds_1 = targetIds; _i < targetIds_1.length; _i++) {
        var targetId = targetIds_1[_i];
        var target = registry.getTarget(targetId);
        target.hover(monitor, targetId);
      }
    }
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/drop.js
var require_drop = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/drop.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var discount_lodash_1 = require_discount_lodash();
    var invariant = require_browser();
    function createDrop(manager) {
      return function drop(options) {
        if (options === void 0) {
          options = {};
        }
        var monitor = manager.getMonitor();
        var registry = manager.getRegistry();
        verifyInvariants(monitor);
        var targetIds = getDroppableTargets(monitor);
        targetIds.forEach(function(targetId, index) {
          var dropResult = determineDropResult(targetId, index, registry, monitor);
          var action = {
            type: types_1.DROP,
            payload: {
              dropResult: __assign({}, options, dropResult)
            }
          };
          manager.dispatch(action);
        });
      };
    }
    exports.default = createDrop;
    function verifyInvariants(monitor) {
      invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
      invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
    }
    function determineDropResult(targetId, index, registry, monitor) {
      var target = registry.getTarget(targetId);
      var dropResult = target ? target.drop(monitor, targetId) : void 0;
      verifyDropResultType(dropResult);
      if (typeof dropResult === "undefined") {
        dropResult = index === 0 ? {} : monitor.getDropResult();
      }
      return dropResult;
    }
    function verifyDropResultType(dropResult) {
      invariant(typeof dropResult === "undefined" || discount_lodash_1.isObject(dropResult), "Drop result must either be an object or undefined.");
    }
    function getDroppableTargets(monitor) {
      var targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
      targetIds.reverse();
      return targetIds;
    }
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/endDrag.js
var require_endDrag = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/endDrag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var invariant = require_browser();
    function createEndDrag(manager) {
      return function endDrag() {
        var monitor = manager.getMonitor();
        var registry = manager.getRegistry();
        verifyIsDragging(monitor);
        var sourceId = monitor.getSourceId();
        var source = registry.getSource(sourceId, true);
        source.endDrag(monitor, sourceId);
        registry.unpinSource();
        return { type: types_1.END_DRAG };
      };
    }
    exports.default = createEndDrag;
    function verifyIsDragging(monitor) {
      invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
    }
  }
});

// node_modules/dnd-core/lib/cjs/actions/dragDrop/index.js
var require_dragDrop = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/dragDrop/index.js"(exports) {
    "use strict";
    function __export2(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var beginDrag_1 = require_beginDrag();
    var publishDragSource_1 = require_publishDragSource();
    var hover_1 = require_hover();
    var drop_1 = require_drop();
    var endDrag_1 = require_endDrag();
    __export2(require_types());
    function createDragDropActions(manager) {
      return {
        beginDrag: beginDrag_1.default(manager),
        publishDragSource: publishDragSource_1.default(manager),
        hover: hover_1.default(manager),
        drop: drop_1.default(manager),
        endDrag: endDrag_1.default(manager)
      };
    }
    exports.default = createDragDropActions;
  }
});

// node_modules/dnd-core/lib/cjs/utils/equality.js
var require_equality = __commonJS({
  "node_modules/dnd-core/lib/cjs/utils/equality.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.strictEquality = function(a, b) {
      return a === b;
    };
    function areCoordsEqual(offsetA, offsetB) {
      if (!offsetA && !offsetB) {
        return true;
      } else if (!offsetA || !offsetB) {
        return false;
      } else {
        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
      }
    }
    exports.areCoordsEqual = areCoordsEqual;
    function areArraysEqual(a, b, isEqual) {
      if (isEqual === void 0) {
        isEqual = exports.strictEquality;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (var i = 0; i < a.length; ++i) {
        if (!isEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    exports.areArraysEqual = areArraysEqual;
  }
});

// node_modules/dnd-core/lib/cjs/reducers/dragOffset.js
var require_dragOffset = __commonJS({
  "node_modules/dnd-core/lib/cjs/reducers/dragOffset.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dragDrop_1 = require_dragDrop();
    var equality_1 = require_equality();
    var initialState = {
      initialSourceClientOffset: null,
      initialClientOffset: null,
      clientOffset: null
    };
    function dragOffset(state, action) {
      if (state === void 0) {
        state = initialState;
      }
      var payload = action.payload;
      switch (action.type) {
        case dragDrop_1.INIT_COORDS:
        case dragDrop_1.BEGIN_DRAG:
          return {
            initialSourceClientOffset: payload.sourceClientOffset,
            initialClientOffset: payload.clientOffset,
            clientOffset: payload.clientOffset
          };
        case dragDrop_1.HOVER:
          if (equality_1.areCoordsEqual(state.clientOffset, payload.clientOffset)) {
            return state;
          }
          return __assign({}, state, { clientOffset: payload.clientOffset });
        case dragDrop_1.END_DRAG:
        case dragDrop_1.DROP:
          return initialState;
        default:
          return state;
      }
    }
    exports.default = dragOffset;
  }
});

// node_modules/dnd-core/lib/cjs/actions/registry.js
var require_registry = __commonJS({
  "node_modules/dnd-core/lib/cjs/actions/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADD_SOURCE = "dnd-core/ADD_SOURCE";
    exports.ADD_TARGET = "dnd-core/ADD_TARGET";
    exports.REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
    exports.REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
    function addSource(sourceId) {
      return {
        type: exports.ADD_SOURCE,
        payload: {
          sourceId
        }
      };
    }
    exports.addSource = addSource;
    function addTarget(targetId) {
      return {
        type: exports.ADD_TARGET,
        payload: {
          targetId
        }
      };
    }
    exports.addTarget = addTarget;
    function removeSource(sourceId) {
      return {
        type: exports.REMOVE_SOURCE,
        payload: {
          sourceId
        }
      };
    }
    exports.removeSource = removeSource;
    function removeTarget(targetId) {
      return {
        type: exports.REMOVE_TARGET,
        payload: {
          targetId
        }
      };
    }
    exports.removeTarget = removeTarget;
  }
});

// node_modules/dnd-core/lib/cjs/reducers/dragOperation.js
var require_dragOperation = __commonJS({
  "node_modules/dnd-core/lib/cjs/reducers/dragOperation.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dragDrop_1 = require_dragDrop();
    var registry_1 = require_registry();
    var discount_lodash_1 = require_discount_lodash();
    var initialState = {
      itemType: null,
      item: null,
      sourceId: null,
      targetIds: [],
      dropResult: null,
      didDrop: false,
      isSourcePublic: null
    };
    function dragOperation(state, action) {
      if (state === void 0) {
        state = initialState;
      }
      var payload = action.payload;
      switch (action.type) {
        case dragDrop_1.BEGIN_DRAG:
          return __assign({}, state, { itemType: payload.itemType, item: payload.item, sourceId: payload.sourceId, isSourcePublic: payload.isSourcePublic, dropResult: null, didDrop: false });
        case dragDrop_1.PUBLISH_DRAG_SOURCE:
          return __assign({}, state, { isSourcePublic: true });
        case dragDrop_1.HOVER:
          return __assign({}, state, { targetIds: payload.targetIds });
        case registry_1.REMOVE_TARGET:
          if (state.targetIds.indexOf(payload.targetId) === -1) {
            return state;
          }
          return __assign({}, state, { targetIds: discount_lodash_1.without(state.targetIds, payload.targetId) });
        case dragDrop_1.DROP:
          return __assign({}, state, { dropResult: payload.dropResult, didDrop: true, targetIds: [] });
        case dragDrop_1.END_DRAG:
          return __assign({}, state, { itemType: null, item: null, sourceId: null, dropResult: null, didDrop: false, isSourcePublic: null, targetIds: [] });
        default:
          return state;
      }
    }
    exports.default = dragOperation;
  }
});

// node_modules/dnd-core/lib/cjs/reducers/refCount.js
var require_refCount = __commonJS({
  "node_modules/dnd-core/lib/cjs/reducers/refCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var registry_1 = require_registry();
    function refCount(state, action) {
      if (state === void 0) {
        state = 0;
      }
      switch (action.type) {
        case registry_1.ADD_SOURCE:
        case registry_1.ADD_TARGET:
          return state + 1;
        case registry_1.REMOVE_SOURCE:
        case registry_1.REMOVE_TARGET:
          return state - 1;
        default:
          return state;
      }
    }
    exports.default = refCount;
  }
});

// node_modules/dnd-core/lib/cjs/utils/dirtiness.js
var require_dirtiness = __commonJS({
  "node_modules/dnd-core/lib/cjs/utils/dirtiness.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var discount_lodash_1 = require_discount_lodash();
    exports.NONE = [];
    exports.ALL = [];
    exports.NONE.__IS_NONE__ = true;
    exports.ALL.__IS_ALL__ = true;
    function areDirty(dirtyIds, handlerIds) {
      if (dirtyIds === exports.NONE) {
        return false;
      }
      if (dirtyIds === exports.ALL || typeof handlerIds === "undefined") {
        return true;
      }
      var commonIds = discount_lodash_1.intersection(handlerIds, dirtyIds);
      return commonIds.length > 0;
    }
    exports.areDirty = areDirty;
  }
});

// node_modules/dnd-core/lib/cjs/reducers/dirtyHandlerIds.js
var require_dirtyHandlerIds = __commonJS({
  "node_modules/dnd-core/lib/cjs/reducers/dirtyHandlerIds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dragDrop_1 = require_dragDrop();
    var registry_1 = require_registry();
    var equality_1 = require_equality();
    var dirtiness_1 = require_dirtiness();
    var discount_lodash_1 = require_discount_lodash();
    function dirtyHandlerIds(state, action) {
      if (state === void 0) {
        state = dirtiness_1.NONE;
      }
      switch (action.type) {
        case dragDrop_1.HOVER:
          break;
        case registry_1.ADD_SOURCE:
        case registry_1.ADD_TARGET:
        case registry_1.REMOVE_TARGET:
        case registry_1.REMOVE_SOURCE:
          return dirtiness_1.NONE;
        case dragDrop_1.BEGIN_DRAG:
        case dragDrop_1.PUBLISH_DRAG_SOURCE:
        case dragDrop_1.END_DRAG:
        case dragDrop_1.DROP:
        default:
          return dirtiness_1.ALL;
      }
      var _a = action.payload, _b = _a.targetIds, targetIds = _b === void 0 ? [] : _b, _c = _a.prevTargetIds, prevTargetIds = _c === void 0 ? [] : _c;
      var result = discount_lodash_1.xor(targetIds, prevTargetIds);
      var didChange = result.length > 0 || !equality_1.areArraysEqual(targetIds, prevTargetIds);
      if (!didChange) {
        return dirtiness_1.NONE;
      }
      var prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
      var innermostTargetId = targetIds[targetIds.length - 1];
      if (prevInnermostTargetId !== innermostTargetId) {
        if (prevInnermostTargetId) {
          result.push(prevInnermostTargetId);
        }
        if (innermostTargetId) {
          result.push(innermostTargetId);
        }
      }
      return result;
    }
    exports.default = dirtyHandlerIds;
  }
});

// node_modules/dnd-core/lib/cjs/reducers/stateId.js
var require_stateId = __commonJS({
  "node_modules/dnd-core/lib/cjs/reducers/stateId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function stateId(state) {
      if (state === void 0) {
        state = 0;
      }
      return state + 1;
    }
    exports.default = stateId;
  }
});

// node_modules/dnd-core/lib/cjs/reducers/index.js
var require_reducers = __commonJS({
  "node_modules/dnd-core/lib/cjs/reducers/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dragOffset_1 = require_dragOffset();
    var dragOperation_1 = require_dragOperation();
    var refCount_1 = require_refCount();
    var dirtyHandlerIds_1 = require_dirtyHandlerIds();
    var stateId_1 = require_stateId();
    var discount_lodash_1 = require_discount_lodash();
    function reduce(state, action) {
      if (state === void 0) {
        state = {};
      }
      return {
        dirtyHandlerIds: dirtyHandlerIds_1.default(state.dirtyHandlerIds, {
          type: action.type,
          payload: __assign({}, action.payload, { prevTargetIds: discount_lodash_1.get(state, "dragOperation.targetIds", []) })
        }),
        dragOffset: dragOffset_1.default(state.dragOffset, action),
        refCount: refCount_1.default(state.refCount, action),
        dragOperation: dragOperation_1.default(state.dragOperation, action),
        stateId: stateId_1.default(state.stateId)
      };
    }
    exports.default = reduce;
  }
});

// node_modules/dnd-core/lib/cjs/utils/coords.js
var require_coords = __commonJS({
  "node_modules/dnd-core/lib/cjs/utils/coords.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function add(a, b) {
      return {
        x: a.x + b.x,
        y: a.y + b.y
      };
    }
    exports.add = add;
    function subtract(a, b) {
      return {
        x: a.x - b.x,
        y: a.y - b.y
      };
    }
    exports.subtract = subtract;
    function getSourceClientOffset(state) {
      var clientOffset = state.clientOffset, initialClientOffset = state.initialClientOffset, initialSourceClientOffset = state.initialSourceClientOffset;
      if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
        return null;
      }
      return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
    }
    exports.getSourceClientOffset = getSourceClientOffset;
    function getDifferenceFromInitialOffset(state) {
      var clientOffset = state.clientOffset, initialClientOffset = state.initialClientOffset;
      if (!clientOffset || !initialClientOffset) {
        return null;
      }
      return subtract(clientOffset, initialClientOffset);
    }
    exports.getDifferenceFromInitialOffset = getDifferenceFromInitialOffset;
  }
});

// node_modules/dnd-core/lib/cjs/DragDropMonitorImpl.js
var require_DragDropMonitorImpl = __commonJS({
  "node_modules/dnd-core/lib/cjs/DragDropMonitorImpl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matchesType_1 = require_matchesType();
    var coords_1 = require_coords();
    var dirtiness_1 = require_dirtiness();
    var invariant = require_browser();
    var DragDropMonitorImpl = (
      /** @class */
      function() {
        function DragDropMonitorImpl2(store, registry) {
          this.store = store;
          this.registry = registry;
        }
        DragDropMonitorImpl2.prototype.subscribeToStateChange = function(listener, options) {
          var _this = this;
          if (options === void 0) {
            options = { handlerIds: void 0 };
          }
          var handlerIds = options.handlerIds;
          invariant(typeof listener === "function", "listener must be a function.");
          invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
          var prevStateId = this.store.getState().stateId;
          var handleChange = function() {
            var state = _this.store.getState();
            var currentStateId = state.stateId;
            try {
              var canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !dirtiness_1.areDirty(state.dirtyHandlerIds, handlerIds);
              if (!canSkipListener) {
                listener();
              }
            } finally {
              prevStateId = currentStateId;
            }
          };
          return this.store.subscribe(handleChange);
        };
        DragDropMonitorImpl2.prototype.subscribeToOffsetChange = function(listener) {
          var _this = this;
          invariant(typeof listener === "function", "listener must be a function.");
          var previousState = this.store.getState().dragOffset;
          var handleChange = function() {
            var nextState = _this.store.getState().dragOffset;
            if (nextState === previousState) {
              return;
            }
            previousState = nextState;
            listener();
          };
          return this.store.subscribe(handleChange);
        };
        DragDropMonitorImpl2.prototype.canDragSource = function(sourceId) {
          if (!sourceId) {
            return false;
          }
          var source = this.registry.getSource(sourceId);
          invariant(source, "Expected to find a valid source.");
          if (this.isDragging()) {
            return false;
          }
          return source.canDrag(this, sourceId);
        };
        DragDropMonitorImpl2.prototype.canDropOnTarget = function(targetId) {
          if (!targetId) {
            return false;
          }
          var target = this.registry.getTarget(targetId);
          invariant(target, "Expected to find a valid target.");
          if (!this.isDragging() || this.didDrop()) {
            return false;
          }
          var targetType = this.registry.getTargetType(targetId);
          var draggedItemType = this.getItemType();
          return matchesType_1.default(targetType, draggedItemType) && target.canDrop(this, targetId);
        };
        DragDropMonitorImpl2.prototype.isDragging = function() {
          return Boolean(this.getItemType());
        };
        DragDropMonitorImpl2.prototype.isDraggingSource = function(sourceId) {
          if (!sourceId) {
            return false;
          }
          var source = this.registry.getSource(sourceId, true);
          invariant(source, "Expected to find a valid source.");
          if (!this.isDragging() || !this.isSourcePublic()) {
            return false;
          }
          var sourceType = this.registry.getSourceType(sourceId);
          var draggedItemType = this.getItemType();
          if (sourceType !== draggedItemType) {
            return false;
          }
          return source.isDragging(this, sourceId);
        };
        DragDropMonitorImpl2.prototype.isOverTarget = function(targetId, options) {
          if (options === void 0) {
            options = { shallow: false };
          }
          if (!targetId) {
            return false;
          }
          var shallow = options.shallow;
          if (!this.isDragging()) {
            return false;
          }
          var targetType = this.registry.getTargetType(targetId);
          var draggedItemType = this.getItemType();
          if (draggedItemType && !matchesType_1.default(targetType, draggedItemType)) {
            return false;
          }
          var targetIds = this.getTargetIds();
          if (!targetIds.length) {
            return false;
          }
          var index = targetIds.indexOf(targetId);
          if (shallow) {
            return index === targetIds.length - 1;
          } else {
            return index > -1;
          }
        };
        DragDropMonitorImpl2.prototype.getItemType = function() {
          return this.store.getState().dragOperation.itemType;
        };
        DragDropMonitorImpl2.prototype.getItem = function() {
          return this.store.getState().dragOperation.item;
        };
        DragDropMonitorImpl2.prototype.getSourceId = function() {
          return this.store.getState().dragOperation.sourceId;
        };
        DragDropMonitorImpl2.prototype.getTargetIds = function() {
          return this.store.getState().dragOperation.targetIds;
        };
        DragDropMonitorImpl2.prototype.getDropResult = function() {
          return this.store.getState().dragOperation.dropResult;
        };
        DragDropMonitorImpl2.prototype.didDrop = function() {
          return this.store.getState().dragOperation.didDrop;
        };
        DragDropMonitorImpl2.prototype.isSourcePublic = function() {
          return this.store.getState().dragOperation.isSourcePublic;
        };
        DragDropMonitorImpl2.prototype.getInitialClientOffset = function() {
          return this.store.getState().dragOffset.initialClientOffset;
        };
        DragDropMonitorImpl2.prototype.getInitialSourceClientOffset = function() {
          return this.store.getState().dragOffset.initialSourceClientOffset;
        };
        DragDropMonitorImpl2.prototype.getClientOffset = function() {
          return this.store.getState().dragOffset.clientOffset;
        };
        DragDropMonitorImpl2.prototype.getSourceClientOffset = function() {
          return coords_1.getSourceClientOffset(this.store.getState().dragOffset);
        };
        DragDropMonitorImpl2.prototype.getDifferenceFromInitialOffset = function() {
          return coords_1.getDifferenceFromInitialOffset(this.store.getState().dragOffset);
        };
        return DragDropMonitorImpl2;
      }()
    );
    exports.default = DragDropMonitorImpl;
  }
});

// node_modules/dnd-core/lib/cjs/utils/getNextUniqueId.js
var require_getNextUniqueId = __commonJS({
  "node_modules/dnd-core/lib/cjs/utils/getNextUniqueId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var nextUniqueId = 0;
    function getNextUniqueId() {
      return nextUniqueId++;
    }
    exports.default = getNextUniqueId;
  }
});

// node_modules/dnd-core/lib/cjs/contracts.js
var require_contracts = __commonJS({
  "node_modules/dnd-core/lib/cjs/contracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var invariant = require_browser();
    function validateSourceContract(source) {
      invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
      invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
      invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
    }
    exports.validateSourceContract = validateSourceContract;
    function validateTargetContract(target) {
      invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
      invariant(typeof target.hover === "function", "Expected hover to be a function.");
      invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
    }
    exports.validateTargetContract = validateTargetContract;
    function validateType(type, allowArray) {
      if (allowArray && Array.isArray(type)) {
        type.forEach(function(t) {
          return validateType(t, false);
        });
        return;
      }
      invariant(typeof type === "string" || typeof type === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
    }
    exports.validateType = validateType;
  }
});

// node_modules/asap/browser-raw.js
var require_browser_raw = __commonJS({
  "node_modules/asap/browser-raw.js"(exports, module) {
    "use strict";
    module.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var requestFlush;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    var scope = typeof global !== "undefined" ? global : self;
    var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === "function") {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
    rawAsap.requestFlush = requestFlush;
    function makeRequestCallFromMutationObserver(callback) {
      var toggle = 1;
      var observer = new BrowserMutationObserver(callback);
      var node = document.createTextNode("");
      observer.observe(node, { characterData: true });
      return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
      };
    }
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        var timeoutHandle = setTimeout(handleTimer, 0);
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
  }
});

// node_modules/asap/browser-asap.js
var require_browser_asap = __commonJS({
  "node_modules/asap/browser-asap.js"(exports, module) {
    "use strict";
    var rawAsap = require_browser_raw();
    var freeTasks = [];
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    function throwFirstError() {
      if (pendingErrors.length) {
        throw pendingErrors.shift();
      }
    }
    module.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
    }
    RawTask.prototype.call = function() {
      try {
        this.task.call();
      } catch (error) {
        if (asap.onerror) {
          asap.onerror(error);
        } else {
          pendingErrors.push(error);
          requestErrorThrow();
        }
      } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
      }
    };
  }
});

// node_modules/dnd-core/lib/cjs/HandlerRegistryImpl.js
var require_HandlerRegistryImpl = __commonJS({
  "node_modules/dnd-core/lib/cjs/HandlerRegistryImpl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var registry_1 = require_registry();
    var getNextUniqueId_1 = require_getNextUniqueId();
    var interfaces_1 = require_interfaces();
    var contracts_1 = require_contracts();
    var invariant = require_browser();
    var asap = require_browser_asap();
    function getNextHandlerId(role) {
      var id = getNextUniqueId_1.default().toString();
      switch (role) {
        case interfaces_1.HandlerRole.SOURCE:
          return "S" + id;
        case interfaces_1.HandlerRole.TARGET:
          return "T" + id;
        default:
          throw new Error("Unknown Handler Role: " + role);
      }
    }
    function parseRoleFromHandlerId(handlerId) {
      switch (handlerId[0]) {
        case "S":
          return interfaces_1.HandlerRole.SOURCE;
        case "T":
          return interfaces_1.HandlerRole.TARGET;
        default:
          invariant(false, "Cannot parse handler ID: " + handlerId);
      }
    }
    function mapContainsValue(map, searchValue) {
      var entries = map.entries();
      var isDone = false;
      do {
        var _a = entries.next(), done = _a.done, _b = _a.value, value = _b[1];
        if (value === searchValue) {
          return true;
        }
        isDone = done;
      } while (!isDone);
      return false;
    }
    var HandlerRegistryImpl = (
      /** @class */
      function() {
        function HandlerRegistryImpl2(store) {
          this.store = store;
          this.types = /* @__PURE__ */ new Map();
          this.dragSources = /* @__PURE__ */ new Map();
          this.dropTargets = /* @__PURE__ */ new Map();
          this.pinnedSourceId = null;
          this.pinnedSource = null;
        }
        HandlerRegistryImpl2.prototype.addSource = function(type, source) {
          contracts_1.validateType(type);
          contracts_1.validateSourceContract(source);
          var sourceId = this.addHandler(interfaces_1.HandlerRole.SOURCE, type, source);
          this.store.dispatch(registry_1.addSource(sourceId));
          return sourceId;
        };
        HandlerRegistryImpl2.prototype.addTarget = function(type, target) {
          contracts_1.validateType(type, true);
          contracts_1.validateTargetContract(target);
          var targetId = this.addHandler(interfaces_1.HandlerRole.TARGET, type, target);
          this.store.dispatch(registry_1.addTarget(targetId));
          return targetId;
        };
        HandlerRegistryImpl2.prototype.containsHandler = function(handler) {
          return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
        };
        HandlerRegistryImpl2.prototype.getSource = function(sourceId, includePinned) {
          if (includePinned === void 0) {
            includePinned = false;
          }
          invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
          var isPinned = includePinned && sourceId === this.pinnedSourceId;
          var source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
          return source;
        };
        HandlerRegistryImpl2.prototype.getTarget = function(targetId) {
          invariant(this.isTargetId(targetId), "Expected a valid target ID.");
          return this.dropTargets.get(targetId);
        };
        HandlerRegistryImpl2.prototype.getSourceType = function(sourceId) {
          invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
          return this.types.get(sourceId);
        };
        HandlerRegistryImpl2.prototype.getTargetType = function(targetId) {
          invariant(this.isTargetId(targetId), "Expected a valid target ID.");
          return this.types.get(targetId);
        };
        HandlerRegistryImpl2.prototype.isSourceId = function(handlerId) {
          var role = parseRoleFromHandlerId(handlerId);
          return role === interfaces_1.HandlerRole.SOURCE;
        };
        HandlerRegistryImpl2.prototype.isTargetId = function(handlerId) {
          var role = parseRoleFromHandlerId(handlerId);
          return role === interfaces_1.HandlerRole.TARGET;
        };
        HandlerRegistryImpl2.prototype.removeSource = function(sourceId) {
          var _this = this;
          invariant(this.getSource(sourceId), "Expected an existing source.");
          this.store.dispatch(registry_1.removeSource(sourceId));
          asap(function() {
            _this.dragSources.delete(sourceId);
            _this.types.delete(sourceId);
          });
        };
        HandlerRegistryImpl2.prototype.removeTarget = function(targetId) {
          invariant(this.getTarget(targetId), "Expected an existing target.");
          this.store.dispatch(registry_1.removeTarget(targetId));
          this.dropTargets.delete(targetId);
          this.types.delete(targetId);
        };
        HandlerRegistryImpl2.prototype.pinSource = function(sourceId) {
          var source = this.getSource(sourceId);
          invariant(source, "Expected an existing source.");
          this.pinnedSourceId = sourceId;
          this.pinnedSource = source;
        };
        HandlerRegistryImpl2.prototype.unpinSource = function() {
          invariant(this.pinnedSource, "No source is pinned at the time.");
          this.pinnedSourceId = null;
          this.pinnedSource = null;
        };
        HandlerRegistryImpl2.prototype.addHandler = function(role, type, handler) {
          var id = getNextHandlerId(role);
          this.types.set(id, type);
          if (role === interfaces_1.HandlerRole.SOURCE) {
            this.dragSources.set(id, handler);
          } else if (role === interfaces_1.HandlerRole.TARGET) {
            this.dropTargets.set(id, handler);
          }
          return id;
        };
        return HandlerRegistryImpl2;
      }()
    );
    exports.default = HandlerRegistryImpl;
  }
});

// node_modules/dnd-core/lib/cjs/DragDropManagerImpl.js
var require_DragDropManagerImpl = __commonJS({
  "node_modules/dnd-core/lib/cjs/DragDropManagerImpl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var redux_1 = (init_redux(), __toCommonJS(redux_exports));
    var reducers_1 = require_reducers();
    var dragDrop_1 = require_dragDrop();
    var DragDropMonitorImpl_1 = require_DragDropMonitorImpl();
    var HandlerRegistryImpl_1 = require_HandlerRegistryImpl();
    function makeStoreInstance(debugMode) {
      var reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
      return redux_1.createStore(reducers_1.default, debugMode && reduxDevTools && reduxDevTools({
        name: "dnd-core",
        instanceId: "dnd-core"
      }));
    }
    var DragDropManagerImpl = (
      /** @class */
      function() {
        function DragDropManagerImpl2(createBackend, context, debugMode) {
          var _this = this;
          if (context === void 0) {
            context = {};
          }
          if (debugMode === void 0) {
            debugMode = false;
          }
          this.context = context;
          this.isSetUp = false;
          this.handleRefCountChange = function() {
            var shouldSetUp = _this.store.getState().refCount > 0;
            if (shouldSetUp && !_this.isSetUp) {
              _this.backend.setup();
              _this.isSetUp = true;
            } else if (!shouldSetUp && _this.isSetUp) {
              _this.backend.teardown();
              _this.isSetUp = false;
            }
          };
          var store = makeStoreInstance(debugMode);
          this.store = store;
          this.monitor = new DragDropMonitorImpl_1.default(store, new HandlerRegistryImpl_1.default(store));
          this.backend = createBackend(this);
          store.subscribe(this.handleRefCountChange);
        }
        DragDropManagerImpl2.prototype.getContext = function() {
          return this.context;
        };
        DragDropManagerImpl2.prototype.getMonitor = function() {
          return this.monitor;
        };
        DragDropManagerImpl2.prototype.getBackend = function() {
          return this.backend;
        };
        DragDropManagerImpl2.prototype.getRegistry = function() {
          return this.monitor.registry;
        };
        DragDropManagerImpl2.prototype.getActions = function() {
          var manager = this;
          var dispatch = this.store.dispatch;
          function bindActionCreator2(actionCreator) {
            return function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var action = actionCreator.apply(manager, args);
              if (typeof action !== "undefined") {
                dispatch(action);
              }
            };
          }
          var actions = dragDrop_1.default(this);
          return Object.keys(actions).reduce(function(boundActions, key) {
            var action = actions[key];
            boundActions[key] = bindActionCreator2(action);
            return boundActions;
          }, {});
        };
        DragDropManagerImpl2.prototype.dispatch = function(action) {
          this.store.dispatch(action);
        };
        return DragDropManagerImpl2;
      }()
    );
    exports.default = DragDropManagerImpl;
  }
});

// node_modules/dnd-core/lib/cjs/factories.js
var require_factories = __commonJS({
  "node_modules/dnd-core/lib/cjs/factories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DragDropManagerImpl_1 = require_DragDropManagerImpl();
    function createDragDropManager(backend, context, debugMode) {
      return new DragDropManagerImpl_1.default(backend, context, debugMode);
    }
    exports.createDragDropManager = createDragDropManager;
  }
});

// node_modules/dnd-core/lib/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/dnd-core/lib/cjs/index.js"(exports) {
    "use strict";
    function __export2(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_interfaces());
    __export2(require_factories());
  }
});

// node_modules/react-dnd/lib/cjs/utils/checkDecoratorArguments.js
var require_checkDecoratorArguments = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/checkDecoratorArguments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function checkDecoratorArguments(functionName, signature) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (true) {
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var arg = args_1[_a];
          if (arg && arg.prototype && arg.prototype.render) {
            console.error("You seem to be applying the arguments in the wrong order. " + ("It should be " + functionName + "(" + signature + ")(Component), not the other way around. ") + "Read more: http://react-dnd.github.io/react-dnd/docs/troubleshooting#you-seem-to-be-applying-the-arguments-in-the-wrong-order");
            return;
          }
        }
      }
    }
    exports.default = checkDecoratorArguments;
  }
});

// node_modules/react-dnd/lib/cjs/utils/isRefable.js
var require_isRefable = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/isRefable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isClassComponent(Component) {
      return Component && Component.prototype && typeof Component.prototype.render === "function";
    }
    function isRefForwardingComponent(C) {
      return C && C.$$typeof && C.$$typeof.toString() === "Symbol(react.forward_ref)";
    }
    exports.isRefForwardingComponent = isRefForwardingComponent;
    function isRefable(C) {
      return isClassComponent(C) || isRefForwardingComponent(C);
    }
    exports.isRefable = isRefable;
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// node_modules/react-dnd/lib/cjs/DragDropContext.js
var require_DragDropContext = __commonJS({
  "node_modules/react-dnd/lib/cjs/DragDropContext.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var dnd_core_1 = require_cjs();
    var checkDecoratorArguments_1 = require_checkDecoratorArguments();
    var isRefable_1 = require_isRefable();
    var invariant = require_browser();
    var hoistStatics = require_hoist_non_react_statics_cjs();
    exports.context = React.createContext({
      dragDropManager: void 0
    });
    exports.Consumer = exports.context.Consumer, exports.Provider = exports.context.Provider;
    function createChildContext(backend, context, debugMode) {
      return {
        dragDropManager: dnd_core_1.createDragDropManager(backend, context, debugMode)
      };
    }
    exports.createChildContext = createChildContext;
    exports.DragDropContextProvider = function(_a) {
      var children = _a.children, props = __rest(_a, ["children"]);
      var contextValue = "manager" in props ? { dragDropManager: props.manager } : createChildContext(props.backend, props.context, props.debugMode);
      return React.createElement(exports.Provider, { value: contextValue }, children);
    };
    function DragDropContext(backendFactory, backendContext, debugMode) {
      checkDecoratorArguments_1.default("DragDropContext", "backend", backendFactory);
      var childContext = createChildContext(backendFactory, backendContext, debugMode);
      return function decorateContext(DecoratedComponent) {
        var Decorated = DecoratedComponent;
        var displayName = Decorated.displayName || Decorated.name || "Component";
        var DragDropContextContainer = (
          /** @class */
          function(_super) {
            __extends(DragDropContextContainer2, _super);
            function DragDropContextContainer2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.ref = React.createRef();
              _this.getManager = function() {
                return childContext.dragDropManager;
              };
              return _this;
            }
            DragDropContextContainer2.prototype.getDecoratedComponentInstance = function() {
              invariant(this.ref.current, "In order to access an instance of the decorated component, it must either be a class component or use React.forwardRef()");
              return this.ref.current;
            };
            DragDropContextContainer2.prototype.render = function() {
              return React.createElement(
                exports.Provider,
                { value: childContext },
                React.createElement(Decorated, __assign({}, this.props, { ref: isRefable_1.isRefable(Decorated) ? this.ref : null }))
              );
            };
            DragDropContextContainer2.DecoratedComponent = DecoratedComponent;
            DragDropContextContainer2.displayName = "DragDropContext(" + displayName + ")";
            return DragDropContextContainer2;
          }(React.Component)
        );
        return hoistStatics(DragDropContextContainer, DecoratedComponent);
      };
    }
    exports.DragDropContext = DragDropContext;
  }
});

// node_modules/react-dnd/lib/cjs/utils/discount_lodash.js
var require_discount_lodash2 = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/discount_lodash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isFunction(input) {
      return typeof input === "function";
    }
    exports.isFunction = isFunction;
    function noop() {
    }
    exports.noop = noop;
    function isObjectLike(input) {
      return typeof input === "object" && input !== null;
    }
    function isPlainObject2(input) {
      if (!isObjectLike(input)) {
        return false;
      }
      if (Object.getPrototypeOf(input) === null) {
        return true;
      }
      var proto = input;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(input) === proto;
    }
    exports.isPlainObject = isPlainObject2;
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/react-dnd/lib/cjs/DragLayer.js
var require_DragLayer = __commonJS({
  "node_modules/react-dnd/lib/cjs/DragLayer.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var checkDecoratorArguments_1 = require_checkDecoratorArguments();
    var DragDropContext_1 = require_DragDropContext();
    var isRefable_1 = require_isRefable();
    var discount_lodash_1 = require_discount_lodash2();
    var hoistStatics = require_hoist_non_react_statics_cjs();
    var invariant = require_browser();
    var shallowEqual = require_shallowequal();
    function DragLayer(collect, options) {
      if (options === void 0) {
        options = {};
      }
      checkDecoratorArguments_1.default("DragLayer", "collect[, options]", collect, options);
      invariant(typeof collect === "function", 'Expected "collect" provided as the first argument to DragLayer to be a function that collects props to inject into the component. ', "Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-layer", collect);
      invariant(discount_lodash_1.isPlainObject(options), 'Expected "options" provided as the second argument to DragLayer to be a plain object when specified. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-layer', options);
      return function decorateLayer(DecoratedComponent) {
        var Decorated = DecoratedComponent;
        var _a = options.arePropsEqual, arePropsEqual = _a === void 0 ? shallowEqual : _a;
        var displayName = Decorated.displayName || Decorated.name || "Component";
        var DragLayerContainer = (
          /** @class */
          function(_super) {
            __extends(DragLayerContainer2, _super);
            function DragLayerContainer2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.isCurrentlyMounted = false;
              _this.ref = React.createRef();
              _this.handleChange = function() {
                if (!_this.isCurrentlyMounted) {
                  return;
                }
                var nextState = _this.getCurrentState();
                if (!shallowEqual(nextState, _this.state)) {
                  _this.setState(nextState);
                }
              };
              return _this;
            }
            DragLayerContainer2.prototype.getDecoratedComponentInstance = function() {
              invariant(this.ref.current, "In order to access an instance of the decorated component, it must either be a class component or use React.forwardRef()");
              return this.ref.current;
            };
            DragLayerContainer2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
              return !arePropsEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);
            };
            DragLayerContainer2.prototype.componentDidMount = function() {
              this.isCurrentlyMounted = true;
              this.handleChange();
            };
            DragLayerContainer2.prototype.componentWillUnmount = function() {
              this.isCurrentlyMounted = false;
              if (this.unsubscribeFromOffsetChange) {
                this.unsubscribeFromOffsetChange();
                this.unsubscribeFromOffsetChange = void 0;
              }
              if (this.unsubscribeFromStateChange) {
                this.unsubscribeFromStateChange();
                this.unsubscribeFromStateChange = void 0;
              }
            };
            DragLayerContainer2.prototype.render = function() {
              var _this = this;
              return React.createElement(DragDropContext_1.Consumer, null, function(_a2) {
                var dragDropManager = _a2.dragDropManager;
                if (dragDropManager === void 0) {
                  return null;
                }
                _this.receiveDragDropManager(dragDropManager);
                if (!_this.isCurrentlyMounted) {
                  return null;
                }
                return React.createElement(Decorated, __assign({}, _this.props, _this.state, { ref: isRefable_1.isRefable(Decorated) ? _this.ref : null }));
              });
            };
            DragLayerContainer2.prototype.receiveDragDropManager = function(dragDropManager) {
              if (this.manager !== void 0) {
                return;
              }
              this.manager = dragDropManager;
              invariant(typeof dragDropManager === "object", "Could not find the drag and drop manager in the context of %s. Make sure to wrap the top-level component of your app with DragDropContext. Read more: http://react-dnd.github.io/react-dnd/docs/troubleshooting#could-not-find-the-drag-and-drop-manager-in-the-context", displayName, displayName);
              var monitor = this.manager.getMonitor();
              this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(this.handleChange);
              this.unsubscribeFromStateChange = monitor.subscribeToStateChange(this.handleChange);
            };
            DragLayerContainer2.prototype.getCurrentState = function() {
              if (!this.manager) {
                return {};
              }
              var monitor = this.manager.getMonitor();
              return collect(monitor, this.props);
            };
            DragLayerContainer2.displayName = "DragLayer(" + displayName + ")";
            DragLayerContainer2.DecoratedComponent = DecoratedComponent;
            return DragLayerContainer2;
          }(React.Component)
        );
        return hoistStatics(DragLayerContainer, DecoratedComponent);
      };
    }
    exports.default = DragLayer;
  }
});

// node_modules/react-dnd/lib/cjs/utils/disposables/Disposable.js
var require_Disposable = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/disposables/Disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var discount_lodash_1 = require_discount_lodash2();
    var Disposable = (
      /** @class */
      function() {
        function Disposable2(action) {
          this.isDisposed = false;
          this.action = discount_lodash_1.isFunction(action) ? action : discount_lodash_1.noop;
        }
        Disposable2.isDisposable = function(d) {
          return d && discount_lodash_1.isFunction(d.dispose);
        };
        Disposable2._fixup = function(result) {
          return Disposable2.isDisposable(result) ? result : Disposable2.empty;
        };
        Disposable2.create = function(action) {
          return new Disposable2(action);
        };
        Disposable2.prototype.dispose = function() {
          if (!this.isDisposed) {
            this.action();
            this.isDisposed = true;
          }
        };
        Disposable2.empty = { dispose: discount_lodash_1.noop };
        return Disposable2;
      }()
    );
    exports.Disposable = Disposable;
  }
});

// node_modules/react-dnd/lib/cjs/utils/disposables/SerialDisposable.js
var require_SerialDisposable = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/disposables/SerialDisposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SerialDisposable = (
      /** @class */
      function() {
        function SerialDisposable2() {
          this.isDisposed = false;
        }
        SerialDisposable2.prototype.getDisposable = function() {
          return this.current;
        };
        SerialDisposable2.prototype.setDisposable = function(value) {
          var shouldDispose = this.isDisposed;
          if (!shouldDispose) {
            var old = this.current;
            this.current = value;
            if (old) {
              old.dispose();
            }
          }
          if (shouldDispose && value) {
            value.dispose();
          }
        };
        SerialDisposable2.prototype.dispose = function() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            var old = this.current;
            this.current = void 0;
            if (old) {
              old.dispose();
            }
          }
        };
        return SerialDisposable2;
      }()
    );
    exports.SerialDisposable = SerialDisposable;
  }
});

// node_modules/react-dnd/lib/cjs/utils/disposables/CompositeDisposable.js
var require_CompositeDisposable = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/disposables/CompositeDisposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompositeDisposable = (
      /** @class */
      function() {
        function CompositeDisposable2() {
          var disposables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            disposables[_i] = arguments[_i];
          }
          this.isDisposed = false;
          this.disposables = disposables;
        }
        CompositeDisposable2.prototype.add = function(item) {
          if (this.isDisposed) {
            item.dispose();
          } else {
            this.disposables.push(item);
          }
        };
        CompositeDisposable2.prototype.remove = function(item) {
          var shouldDispose = false;
          if (!this.isDisposed) {
            var idx = this.disposables.indexOf(item);
            if (idx !== -1) {
              shouldDispose = true;
              this.disposables.splice(idx, 1);
              item.dispose();
            }
          }
          return shouldDispose;
        };
        CompositeDisposable2.prototype.clear = function() {
          if (!this.isDisposed) {
            var len = this.disposables.length;
            var currentDisposables = new Array(len);
            for (var i = 0; i < len; i++) {
              currentDisposables[i] = this.disposables[i];
            }
            this.disposables = [];
            for (var i = 0; i < len; i++) {
              currentDisposables[i].dispose();
            }
          }
        };
        CompositeDisposable2.prototype.dispose = function() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            var len = this.disposables.length;
            var currentDisposables = new Array(len);
            for (var i = 0; i < len; i++) {
              currentDisposables[i] = this.disposables[i];
            }
            this.disposables = [];
            for (var i = 0; i < len; i++) {
              currentDisposables[i].dispose();
            }
          }
        };
        return CompositeDisposable2;
      }()
    );
    exports.CompositeDisposable = CompositeDisposable;
  }
});

// node_modules/react-dnd/lib/cjs/utils/disposables/index.js
var require_disposables = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/disposables/index.js"(exports) {
    "use strict";
    function __export2(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_Disposable());
    __export2(require_SerialDisposable());
    __export2(require_CompositeDisposable());
  }
});

// node_modules/react-dnd/lib/cjs/decorateHandler.js
var require_decorateHandler = __commonJS({
  "node_modules/react-dnd/lib/cjs/decorateHandler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var DragDropContext_1 = require_DragDropContext();
    var disposables_1 = require_disposables();
    var isRefable_1 = require_isRefable();
    var discount_lodash_1 = require_discount_lodash2();
    var invariant = require_browser();
    var hoistStatics = require_hoist_non_react_statics_cjs();
    var shallowEqual = require_shallowequal();
    function decorateHandler(_a) {
      var DecoratedComponent = _a.DecoratedComponent, createHandler = _a.createHandler, createMonitor = _a.createMonitor, createConnector = _a.createConnector, registerHandler = _a.registerHandler, containerDisplayName = _a.containerDisplayName, getType = _a.getType, collect = _a.collect, options = _a.options;
      var _b = options.arePropsEqual, arePropsEqual = _b === void 0 ? shallowEqual : _b;
      var Decorated = DecoratedComponent;
      var displayName = DecoratedComponent.displayName || DecoratedComponent.name || "Component";
      var DragDropContainer = (
        /** @class */
        function(_super) {
          __extends(DragDropContainer2, _super);
          function DragDropContainer2(props) {
            var _this = _super.call(this, props) || this;
            _this.decoratedRef = React.createRef();
            _this.handleChange = function() {
              var nextState = _this.getCurrentState();
              if (!shallowEqual(nextState, _this.state)) {
                _this.setState(nextState);
              }
            };
            _this.disposable = new disposables_1.SerialDisposable();
            _this.receiveProps(props);
            _this.dispose();
            return _this;
          }
          DragDropContainer2.prototype.getHandlerId = function() {
            return this.handlerId;
          };
          DragDropContainer2.prototype.getDecoratedComponentInstance = function() {
            invariant(this.decoratedRef.current, "In order to access an instance of the decorated component, it must either be a class component or use React.forwardRef()");
            return this.decoratedRef.current;
          };
          DragDropContainer2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
            return !arePropsEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);
          };
          DragDropContainer2.prototype.componentDidMount = function() {
            this.disposable = new disposables_1.SerialDisposable();
            this.currentType = void 0;
            this.receiveProps(this.props);
            this.handleChange();
          };
          DragDropContainer2.prototype.componentDidUpdate = function(prevProps) {
            if (!arePropsEqual(this.props, prevProps)) {
              this.receiveProps(this.props);
              this.handleChange();
            }
          };
          DragDropContainer2.prototype.componentWillUnmount = function() {
            this.dispose();
          };
          DragDropContainer2.prototype.receiveProps = function(props) {
            if (!this.handler) {
              return;
            }
            this.handler.receiveProps(props);
            this.receiveType(getType(props));
          };
          DragDropContainer2.prototype.receiveType = function(type) {
            if (!this.handlerMonitor || !this.manager || !this.handlerConnector) {
              return;
            }
            if (type === this.currentType) {
              return;
            }
            this.currentType = type;
            var _a2 = registerHandler(type, this.handler, this.manager), handlerId = _a2[0], unregister = _a2[1];
            this.handlerId = handlerId;
            this.handlerMonitor.receiveHandlerId(handlerId);
            this.handlerConnector.receiveHandlerId(handlerId);
            var globalMonitor = this.manager.getMonitor();
            var unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, { handlerIds: [handlerId] });
            this.disposable.setDisposable(new disposables_1.CompositeDisposable(new disposables_1.Disposable(unsubscribe), new disposables_1.Disposable(unregister)));
          };
          DragDropContainer2.prototype.dispose = function() {
            this.disposable.dispose();
            if (this.handlerConnector) {
              this.handlerConnector.receiveHandlerId(null);
            }
          };
          DragDropContainer2.prototype.getCurrentState = function() {
            if (!this.handlerConnector) {
              return {};
            }
            var nextState = collect(this.handlerConnector.hooks, this.handlerMonitor, this.props);
            if (true) {
              invariant(discount_lodash_1.isPlainObject(nextState), "Expected `collect` specified as the second argument to %s for %s to return a plain object of props to inject. Instead, received %s.", containerDisplayName, displayName, nextState);
            }
            return nextState;
          };
          DragDropContainer2.prototype.render = function() {
            var _this = this;
            return React.createElement(DragDropContext_1.Consumer, null, function(_a2) {
              var dragDropManager = _a2.dragDropManager;
              _this.receiveDragDropManager(dragDropManager);
              if (typeof requestAnimationFrame !== "undefined") {
                requestAnimationFrame(function() {
                  return _this.handlerConnector.reconnect();
                });
              }
              return React.createElement(Decorated, __assign({}, _this.props, _this.getCurrentState(), {
                // NOTE: if Decorated is a Function Component, decoratedRef will not be populated unless it's a refforwarding component.
                ref: isRefable_1.isRefable(Decorated) ? _this.decoratedRef : null
              }));
            });
          };
          DragDropContainer2.prototype.receiveDragDropManager = function(dragDropManager) {
            if (this.manager !== void 0) {
              return;
            }
            invariant(dragDropManager !== void 0, "Could not find the drag and drop manager in the context of %s. Make sure to wrap the top-level component of your app with DragDropContext. Read more: http://react-dnd.github.io/react-dnd/docs/troubleshooting#could-not-find-the-drag-and-drop-manager-in-the-context", displayName, displayName);
            if (dragDropManager === void 0) {
              return;
            }
            this.manager = dragDropManager;
            this.handlerMonitor = createMonitor(dragDropManager);
            this.handlerConnector = createConnector(dragDropManager.getBackend());
            this.handler = createHandler(this.handlerMonitor, this.decoratedRef);
          };
          DragDropContainer2.DecoratedComponent = DecoratedComponent;
          DragDropContainer2.displayName = containerDisplayName + "(" + displayName + ")";
          return DragDropContainer2;
        }(React.Component)
      );
      return hoistStatics(DragDropContainer, DecoratedComponent);
    }
    exports.default = decorateHandler;
  }
});

// node_modules/react-dnd/lib/cjs/registerSource.js
var require_registerSource = __commonJS({
  "node_modules/react-dnd/lib/cjs/registerSource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function registerSource(type, source, manager) {
      var registry = manager.getRegistry();
      var sourceId = registry.addSource(type, source);
      return [sourceId, function() {
        return registry.removeSource(sourceId);
      }];
    }
    exports.default = registerSource;
  }
});

// node_modules/react-dnd/lib/cjs/utils/getDecoratedComponent.js
var require_getDecoratedComponent = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/getDecoratedComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getDecoratedComponent(instanceRef) {
      var currentRef = instanceRef.current;
      if (currentRef == null) {
        return null;
      } else if (currentRef.decoratedRef) {
        return currentRef.decoratedRef.current;
      } else {
        return currentRef;
      }
    }
    exports.getDecoratedComponent = getDecoratedComponent;
  }
});

// node_modules/react-dnd/lib/cjs/createSourceFactory.js
var require_createSourceFactory = __commonJS({
  "node_modules/react-dnd/lib/cjs/createSourceFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var getDecoratedComponent_1 = require_getDecoratedComponent();
    var discount_lodash_1 = require_discount_lodash2();
    var invariant = require_browser();
    var ALLOWED_SPEC_METHODS = ["canDrag", "beginDrag", "isDragging", "endDrag"];
    var REQUIRED_SPEC_METHODS = ["beginDrag"];
    var SourceImpl = (
      /** @class */
      function() {
        function SourceImpl2(spec, monitor, ref) {
          var _this = this;
          this.spec = spec;
          this.monitor = monitor;
          this.ref = ref;
          this.props = null;
          this.beginDrag = function() {
            if (!_this.props) {
              return;
            }
            var item = _this.spec.beginDrag(_this.props, _this.monitor, _this.ref.current);
            if (true) {
              invariant(discount_lodash_1.isPlainObject(item), "beginDrag() must return a plain object that represents the dragged item. Instead received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source", item);
            }
            return item;
          };
        }
        SourceImpl2.prototype.receiveProps = function(props) {
          this.props = props;
        };
        SourceImpl2.prototype.canDrag = function() {
          if (!this.props) {
            return false;
          }
          if (!this.spec.canDrag) {
            return true;
          }
          return this.spec.canDrag(this.props, this.monitor);
        };
        SourceImpl2.prototype.isDragging = function(globalMonitor, sourceId) {
          if (!this.props) {
            return false;
          }
          if (!this.spec.isDragging) {
            return sourceId === globalMonitor.getSourceId();
          }
          return this.spec.isDragging(this.props, this.monitor);
        };
        SourceImpl2.prototype.endDrag = function() {
          if (!this.props) {
            return;
          }
          if (!this.spec.endDrag) {
            return;
          }
          this.spec.endDrag(this.props, this.monitor, getDecoratedComponent_1.getDecoratedComponent(this.ref));
        };
        return SourceImpl2;
      }()
    );
    function createSourceFactory(spec) {
      Object.keys(spec).forEach(function(key) {
        invariant(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drag source specification to only have some of the following keys: %s. Instead received a specification with an unexpected "%s" key. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', ALLOWED_SPEC_METHODS.join(", "), key);
        invariant(typeof spec[key] === "function", "Expected %s in the drag source specification to be a function. Instead received a specification with %s: %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source", key, key, spec[key]);
      });
      REQUIRED_SPEC_METHODS.forEach(function(key) {
        invariant(typeof spec[key] === "function", "Expected %s in the drag source specification to be a function. Instead received a specification with %s: %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source", key, key, spec[key]);
      });
      return function createSource(monitor, ref) {
        return new SourceImpl(spec, monitor, ref);
      };
    }
    exports.default = createSourceFactory;
  }
});

// node_modules/react-dnd/lib/cjs/DragSourceMonitorImpl.js
var require_DragSourceMonitorImpl = __commonJS({
  "node_modules/react-dnd/lib/cjs/DragSourceMonitorImpl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var invariant = require_browser();
    var isCallingCanDrag = false;
    var isCallingIsDragging = false;
    var DragSourceMonitorImpl = (
      /** @class */
      function() {
        function DragSourceMonitorImpl2(manager) {
          this.sourceId = null;
          this.internalMonitor = manager.getMonitor();
        }
        DragSourceMonitorImpl2.prototype.receiveHandlerId = function(sourceId) {
          this.sourceId = sourceId;
        };
        DragSourceMonitorImpl2.prototype.getHandlerId = function() {
          return this.sourceId;
        };
        DragSourceMonitorImpl2.prototype.canDrag = function() {
          invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
          try {
            isCallingCanDrag = true;
            return this.internalMonitor.canDragSource(this.sourceId);
          } finally {
            isCallingCanDrag = false;
          }
        };
        DragSourceMonitorImpl2.prototype.isDragging = function() {
          if (!this.sourceId) {
            return false;
          }
          invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
          try {
            isCallingIsDragging = true;
            return this.internalMonitor.isDraggingSource(this.sourceId);
          } finally {
            isCallingIsDragging = false;
          }
        };
        DragSourceMonitorImpl2.prototype.subscribeToStateChange = function(listener, options) {
          return this.internalMonitor.subscribeToStateChange(listener, options);
        };
        DragSourceMonitorImpl2.prototype.isDraggingSource = function(sourceId) {
          return this.internalMonitor.isDraggingSource(sourceId);
        };
        DragSourceMonitorImpl2.prototype.isOverTarget = function(targetId, options) {
          return this.internalMonitor.isOverTarget(targetId, options);
        };
        DragSourceMonitorImpl2.prototype.getTargetIds = function() {
          return this.internalMonitor.getTargetIds();
        };
        DragSourceMonitorImpl2.prototype.isSourcePublic = function() {
          return this.internalMonitor.isSourcePublic();
        };
        DragSourceMonitorImpl2.prototype.getSourceId = function() {
          return this.internalMonitor.getSourceId();
        };
        DragSourceMonitorImpl2.prototype.subscribeToOffsetChange = function(listener) {
          return this.internalMonitor.subscribeToOffsetChange(listener);
        };
        DragSourceMonitorImpl2.prototype.canDragSource = function(sourceId) {
          return this.internalMonitor.canDragSource(sourceId);
        };
        DragSourceMonitorImpl2.prototype.canDropOnTarget = function(targetId) {
          return this.internalMonitor.canDropOnTarget(targetId);
        };
        DragSourceMonitorImpl2.prototype.getItemType = function() {
          return this.internalMonitor.getItemType();
        };
        DragSourceMonitorImpl2.prototype.getItem = function() {
          return this.internalMonitor.getItem();
        };
        DragSourceMonitorImpl2.prototype.getDropResult = function() {
          return this.internalMonitor.getDropResult();
        };
        DragSourceMonitorImpl2.prototype.didDrop = function() {
          return this.internalMonitor.didDrop();
        };
        DragSourceMonitorImpl2.prototype.getInitialClientOffset = function() {
          return this.internalMonitor.getInitialClientOffset();
        };
        DragSourceMonitorImpl2.prototype.getInitialSourceClientOffset = function() {
          return this.internalMonitor.getInitialSourceClientOffset();
        };
        DragSourceMonitorImpl2.prototype.getSourceClientOffset = function() {
          return this.internalMonitor.getSourceClientOffset();
        };
        DragSourceMonitorImpl2.prototype.getClientOffset = function() {
          return this.internalMonitor.getClientOffset();
        };
        DragSourceMonitorImpl2.prototype.getDifferenceFromInitialOffset = function() {
          return this.internalMonitor.getDifferenceFromInitialOffset();
        };
        return DragSourceMonitorImpl2;
      }()
    );
    exports.default = DragSourceMonitorImpl;
  }
});

// node_modules/react-dnd/lib/cjs/utils/cloneWithRef.js
var require_cloneWithRef = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/cloneWithRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var invariant = require_browser();
    function setRef(ref, node) {
      if (typeof ref === "function") {
        ref(node);
      } else {
        ref.current = node;
      }
    }
    function cloneWithRef(element, newRef) {
      var previousRef = element.ref;
      invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute");
      if (!previousRef) {
        return react_1.cloneElement(element, {
          ref: newRef
        });
      }
      return react_1.cloneElement(element, {
        ref: function(node) {
          setRef(newRef, node);
          if (previousRef) {
            setRef(previousRef, node);
          }
        }
      });
    }
    exports.default = cloneWithRef;
  }
});

// node_modules/react-dnd/lib/cjs/utils/polyfills/endsWith.js
var require_endsWith = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/polyfills/endsWith.js"() {
    "use strict";
    if (!String.prototype.endsWith) {
      String.prototype.endsWith = function(search, thisLen) {
        if (thisLen === void 0 || thisLen > this.length) {
          thisLen = this.length;
        }
        return this.substring(thisLen - search.length, thisLen) === search;
      };
    }
  }
});

// node_modules/react-dnd/lib/cjs/wrapConnectorHooks.js
var require_wrapConnectorHooks = __commonJS({
  "node_modules/react-dnd/lib/cjs/wrapConnectorHooks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var cloneWithRef_1 = require_cloneWithRef();
    require_endsWith();
    function throwIfCompositeComponentElement(element) {
      if (typeof element.type === "string") {
        return;
      }
      var displayName = element.type.displayName || element.type.name || "the component";
      throw new Error("Only native element nodes can now be passed to React DnD connectors." + ("You can either wrap " + displayName + " into a <div>, or turn it into a ") + "drag source or a drop target itself.");
    }
    function wrapHookToRecognizeElement(hook) {
      return function(elementOrNode, options) {
        if (elementOrNode === void 0) {
          elementOrNode = null;
        }
        if (options === void 0) {
          options = null;
        }
        if (!react_1.isValidElement(elementOrNode)) {
          var node = elementOrNode;
          hook(node, options);
          return node;
        }
        var element = elementOrNode;
        throwIfCompositeComponentElement(element);
        var ref = options ? function(node2) {
          return hook(node2, options);
        } : hook;
        return cloneWithRef_1.default(element, ref);
      };
    }
    function wrapConnectorHooks(hooks) {
      var wrappedHooks = {};
      Object.keys(hooks).forEach(function(key) {
        var hook = hooks[key];
        if (key.endsWith("Ref")) {
          wrappedHooks[key] = hooks[key];
        } else {
          var wrappedHook_1 = wrapHookToRecognizeElement(hook);
          wrappedHooks[key] = function() {
            return wrappedHook_1;
          };
        }
      });
      return wrappedHooks;
    }
    exports.default = wrapConnectorHooks;
  }
});

// node_modules/react-dnd/lib/cjs/utils/isRef.js
var require_isRef = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/isRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isRef(obj) {
      return obj !== null && typeof obj === "object" && obj.hasOwnProperty("current");
    }
    exports.isRef = isRef;
  }
});

// node_modules/react-dnd/lib/cjs/SourceConnector.js
var require_SourceConnector = __commonJS({
  "node_modules/react-dnd/lib/cjs/SourceConnector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var wrapConnectorHooks_1 = require_wrapConnectorHooks();
    var isRef_1 = require_isRef();
    var shallowEqual = require_shallowequal();
    var SourceConnector = (
      /** @class */
      function() {
        function SourceConnector2(backend) {
          var _this = this;
          this.backend = backend;
          this.hooks = wrapConnectorHooks_1.default({
            dragSource: function(node, options) {
              _this.dragSourceOptions = options || null;
              if (isRef_1.isRef(node)) {
                _this.dragSourceRef = node;
              } else {
                _this.dragSourceNode = node;
              }
              _this.reconnectDragSource();
            },
            dragPreview: function(node, options) {
              _this.dragPreviewOptions = options || null;
              if (isRef_1.isRef(node)) {
                _this.dragPreviewRef = node;
              } else {
                _this.dragPreviewNode = node;
              }
              _this.reconnectDragPreview();
            }
          });
          this.handlerId = null;
          this.dragSourceRef = null;
          this.dragSourceOptionsInternal = null;
          this.dragPreviewRef = null;
          this.dragPreviewOptionsInternal = null;
          this.lastConnectedHandlerId = null;
          this.lastConnectedDragSource = null;
          this.lastConnectedDragSourceOptions = null;
          this.lastConnectedDragPreview = null;
          this.lastConnectedDragPreviewOptions = null;
        }
        SourceConnector2.prototype.receiveHandlerId = function(newHandlerId) {
          if (this.handlerId === newHandlerId) {
            return;
          }
          this.handlerId = newHandlerId;
          this.reconnect();
        };
        Object.defineProperty(SourceConnector2.prototype, "connectTarget", {
          get: function() {
            return this.dragSource;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(SourceConnector2.prototype, "dragSourceOptions", {
          get: function() {
            return this.dragSourceOptionsInternal;
          },
          set: function(options) {
            this.dragSourceOptionsInternal = options;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(SourceConnector2.prototype, "dragPreviewOptions", {
          get: function() {
            return this.dragPreviewOptionsInternal;
          },
          set: function(options) {
            this.dragPreviewOptionsInternal = options;
          },
          enumerable: true,
          configurable: true
        });
        SourceConnector2.prototype.reconnect = function() {
          this.reconnectDragSource();
          this.reconnectDragPreview();
        };
        SourceConnector2.prototype.reconnectDragSource = function() {
          var didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
          if (didChange) {
            this.disconnectDragSource();
          }
          var dragSource = this.dragSource;
          if (!this.handlerId) {
            return;
          }
          if (!dragSource) {
            this.lastConnectedDragSource = dragSource;
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragSource = dragSource;
            this.lastConnectedDragSourceOptions = this.dragSourceOptions;
            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
          }
        };
        SourceConnector2.prototype.reconnectDragPreview = function() {
          var didChange = this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
          if (didChange) {
            this.disconnectDragPreview();
          }
          var dragPreview = this.dragPreview;
          if (!this.handlerId || !dragPreview) {
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragPreview = dragPreview;
            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
          }
        };
        SourceConnector2.prototype.didHandlerIdChange = function() {
          return this.lastConnectedHandlerId !== this.handlerId;
        };
        SourceConnector2.prototype.didConnectedDragSourceChange = function() {
          return this.lastConnectedDragSource !== this.dragSource;
        };
        SourceConnector2.prototype.didConnectedDragPreviewChange = function() {
          return this.lastConnectedDragPreview !== this.dragPreview;
        };
        SourceConnector2.prototype.didDragSourceOptionsChange = function() {
          return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
        };
        SourceConnector2.prototype.didDragPreviewOptionsChange = function() {
          return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
        };
        SourceConnector2.prototype.disconnectDragSource = function() {
          if (this.dragSourceUnsubscribe) {
            this.dragSourceUnsubscribe();
            this.dragSourceUnsubscribe = void 0;
            this.dragPreviewNode = null;
            this.dragPreviewRef = null;
          }
        };
        SourceConnector2.prototype.disconnectDragPreview = function() {
          if (this.dragPreviewUnsubscribe) {
            this.dragPreviewUnsubscribe();
            this.dragPreviewUnsubscribe = void 0;
            this.dragPreviewNode = null;
            this.dragPreviewRef = null;
          }
        };
        Object.defineProperty(SourceConnector2.prototype, "dragSource", {
          get: function() {
            return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(SourceConnector2.prototype, "dragPreview", {
          get: function() {
            return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
          },
          enumerable: true,
          configurable: true
        });
        return SourceConnector2;
      }()
    );
    exports.default = SourceConnector;
  }
});

// node_modules/react-dnd/lib/cjs/utils/isValidType.js
var require_isValidType = __commonJS({
  "node_modules/react-dnd/lib/cjs/utils/isValidType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isValidType(type, allowArray) {
      return typeof type === "string" || typeof type === "symbol" || !!allowArray && Array.isArray(type) && type.every(function(t) {
        return isValidType(t, false);
      });
    }
    exports.default = isValidType;
  }
});

// node_modules/react-dnd/lib/cjs/DragSource.js
var require_DragSource = __commonJS({
  "node_modules/react-dnd/lib/cjs/DragSource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var checkDecoratorArguments_1 = require_checkDecoratorArguments();
    var decorateHandler_1 = require_decorateHandler();
    var registerSource_1 = require_registerSource();
    var createSourceFactory_1 = require_createSourceFactory();
    var DragSourceMonitorImpl_1 = require_DragSourceMonitorImpl();
    var SourceConnector_1 = require_SourceConnector();
    var isValidType_1 = require_isValidType();
    var discount_lodash_1 = require_discount_lodash2();
    var invariant = require_browser();
    function DragSource(type, spec, collect, options) {
      if (options === void 0) {
        options = {};
      }
      checkDecoratorArguments_1.default("DragSource", "type, spec, collect[, options]", type, spec, collect, options);
      var getType = type;
      if (typeof type !== "function") {
        invariant(isValidType_1.default(type), 'Expected "type" provided as the first argument to DragSource to be a string, or a function that returns a string given the current props. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', type);
        getType = function() {
          return type;
        };
      }
      invariant(discount_lodash_1.isPlainObject(spec), 'Expected "spec" provided as the second argument to DragSource to be a plain object. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', spec);
      var createSource = createSourceFactory_1.default(spec);
      invariant(typeof collect === "function", 'Expected "collect" provided as the third argument to DragSource to be a function that returns a plain object of props to inject. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', collect);
      invariant(discount_lodash_1.isPlainObject(options), 'Expected "options" provided as the fourth argument to DragSource to be a plain object when specified. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', collect);
      return function decorateSource(DecoratedComponent) {
        return decorateHandler_1.default({
          containerDisplayName: "DragSource",
          createHandler: createSource,
          registerHandler: registerSource_1.default,
          createConnector: function(backend) {
            return new SourceConnector_1.default(backend);
          },
          createMonitor: function(manager) {
            return new DragSourceMonitorImpl_1.default(manager);
          },
          DecoratedComponent,
          getType,
          collect,
          options
        });
      };
    }
    exports.default = DragSource;
  }
});

// node_modules/react-dnd/lib/cjs/registerTarget.js
var require_registerTarget = __commonJS({
  "node_modules/react-dnd/lib/cjs/registerTarget.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function registerTarget(type, target, manager) {
      var registry = manager.getRegistry();
      var targetId = registry.addTarget(type, target);
      return [targetId, function() {
        return registry.removeTarget(targetId);
      }];
    }
    exports.default = registerTarget;
  }
});

// node_modules/react-dnd/lib/cjs/createTargetFactory.js
var require_createTargetFactory = __commonJS({
  "node_modules/react-dnd/lib/cjs/createTargetFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var getDecoratedComponent_1 = require_getDecoratedComponent();
    var discount_lodash_1 = require_discount_lodash2();
    var invariant = require_browser();
    var ALLOWED_SPEC_METHODS = ["canDrop", "hover", "drop"];
    var TargetImpl = (
      /** @class */
      function() {
        function TargetImpl2(spec, monitor, ref) {
          this.spec = spec;
          this.monitor = monitor;
          this.ref = ref;
          this.props = null;
        }
        TargetImpl2.prototype.receiveProps = function(props) {
          this.props = props;
        };
        TargetImpl2.prototype.receiveMonitor = function(monitor) {
          this.monitor = monitor;
        };
        TargetImpl2.prototype.canDrop = function() {
          if (!this.spec.canDrop) {
            return true;
          }
          return this.spec.canDrop(this.props, this.monitor);
        };
        TargetImpl2.prototype.hover = function() {
          if (!this.spec.hover) {
            return;
          }
          this.spec.hover(this.props, this.monitor, getDecoratedComponent_1.getDecoratedComponent(this.ref));
        };
        TargetImpl2.prototype.drop = function() {
          if (!this.spec.drop) {
            return void 0;
          }
          var dropResult = this.spec.drop(this.props, this.monitor, this.ref.current);
          if (true) {
            invariant(typeof dropResult === "undefined" || discount_lodash_1.isPlainObject(dropResult), "drop() must either return undefined, or an object that represents the drop result. Instead received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target", dropResult);
          }
          return dropResult;
        };
        return TargetImpl2;
      }()
    );
    function createTargetFactory(spec) {
      Object.keys(spec).forEach(function(key) {
        invariant(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drop target specification to only have some of the following keys: %s. Instead received a specification with an unexpected "%s" key. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', ALLOWED_SPEC_METHODS.join(", "), key);
        invariant(typeof spec[key] === "function", "Expected %s in the drop target specification to be a function. Instead received a specification with %s: %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target", key, key, spec[key]);
      });
      return function createTarget(monitor, ref) {
        return new TargetImpl(spec, monitor, ref);
      };
    }
    exports.default = createTargetFactory;
  }
});

// node_modules/react-dnd/lib/cjs/DropTargetMonitorImpl.js
var require_DropTargetMonitorImpl = __commonJS({
  "node_modules/react-dnd/lib/cjs/DropTargetMonitorImpl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var invariant = require_browser();
    var isCallingCanDrop = false;
    var DropTargetMonitorImpl = (
      /** @class */
      function() {
        function DropTargetMonitorImpl2(manager) {
          this.targetId = null;
          this.internalMonitor = manager.getMonitor();
        }
        DropTargetMonitorImpl2.prototype.receiveHandlerId = function(targetId) {
          this.targetId = targetId;
        };
        DropTargetMonitorImpl2.prototype.getHandlerId = function() {
          return this.targetId;
        };
        DropTargetMonitorImpl2.prototype.subscribeToStateChange = function(listener, options) {
          return this.internalMonitor.subscribeToStateChange(listener, options);
        };
        DropTargetMonitorImpl2.prototype.canDrop = function() {
          if (!this.targetId) {
            return false;
          }
          invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
          try {
            isCallingCanDrop = true;
            return this.internalMonitor.canDropOnTarget(this.targetId);
          } finally {
            isCallingCanDrop = false;
          }
        };
        DropTargetMonitorImpl2.prototype.isOver = function(options) {
          if (!this.targetId) {
            return false;
          }
          return this.internalMonitor.isOverTarget(this.targetId, options);
        };
        DropTargetMonitorImpl2.prototype.getItemType = function() {
          return this.internalMonitor.getItemType();
        };
        DropTargetMonitorImpl2.prototype.getItem = function() {
          return this.internalMonitor.getItem();
        };
        DropTargetMonitorImpl2.prototype.getDropResult = function() {
          return this.internalMonitor.getDropResult();
        };
        DropTargetMonitorImpl2.prototype.didDrop = function() {
          return this.internalMonitor.didDrop();
        };
        DropTargetMonitorImpl2.prototype.getInitialClientOffset = function() {
          return this.internalMonitor.getInitialClientOffset();
        };
        DropTargetMonitorImpl2.prototype.getInitialSourceClientOffset = function() {
          return this.internalMonitor.getInitialSourceClientOffset();
        };
        DropTargetMonitorImpl2.prototype.getSourceClientOffset = function() {
          return this.internalMonitor.getSourceClientOffset();
        };
        DropTargetMonitorImpl2.prototype.getClientOffset = function() {
          return this.internalMonitor.getClientOffset();
        };
        DropTargetMonitorImpl2.prototype.getDifferenceFromInitialOffset = function() {
          return this.internalMonitor.getDifferenceFromInitialOffset();
        };
        return DropTargetMonitorImpl2;
      }()
    );
    exports.default = DropTargetMonitorImpl;
  }
});

// node_modules/react-dnd/lib/cjs/TargetConnector.js
var require_TargetConnector = __commonJS({
  "node_modules/react-dnd/lib/cjs/TargetConnector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var wrapConnectorHooks_1 = require_wrapConnectorHooks();
    var isRef_1 = require_isRef();
    var shallowEqual = require_shallowequal();
    var TargetConnector = (
      /** @class */
      function() {
        function TargetConnector2(backend) {
          var _this = this;
          this.backend = backend;
          this.hooks = wrapConnectorHooks_1.default({
            dropTarget: function(node, options) {
              _this.dropTargetOptions = options;
              if (isRef_1.isRef(node)) {
                _this.dropTargetRef = node;
              } else {
                _this.dropTargetNode = node;
              }
              _this.reconnect();
            }
          });
          this.handlerId = null;
          this.dropTargetRef = null;
          this.dropTargetOptionsInternal = null;
          this.lastConnectedHandlerId = null;
          this.lastConnectedDropTarget = null;
          this.lastConnectedDropTargetOptions = null;
        }
        Object.defineProperty(TargetConnector2.prototype, "connectTarget", {
          get: function() {
            return this.dropTarget;
          },
          enumerable: true,
          configurable: true
        });
        TargetConnector2.prototype.reconnect = function() {
          var didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
          if (didChange) {
            this.disconnectDropTarget();
          }
          var dropTarget = this.dropTarget;
          if (!this.handlerId) {
            return;
          }
          if (!dropTarget) {
            this.lastConnectedDropTarget = dropTarget;
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDropTarget = dropTarget;
            this.lastConnectedDropTargetOptions = this.dropTargetOptions;
            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
          }
        };
        TargetConnector2.prototype.receiveHandlerId = function(newHandlerId) {
          if (newHandlerId === this.handlerId) {
            return;
          }
          this.handlerId = newHandlerId;
          this.reconnect();
        };
        Object.defineProperty(TargetConnector2.prototype, "dropTargetOptions", {
          get: function() {
            return this.dropTargetOptionsInternal;
          },
          set: function(options) {
            this.dropTargetOptionsInternal = options;
          },
          enumerable: true,
          configurable: true
        });
        TargetConnector2.prototype.didHandlerIdChange = function() {
          return this.lastConnectedHandlerId !== this.handlerId;
        };
        TargetConnector2.prototype.didDropTargetChange = function() {
          return this.lastConnectedDropTarget !== this.dropTarget;
        };
        TargetConnector2.prototype.didOptionsChange = function() {
          return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
        };
        TargetConnector2.prototype.disconnectDropTarget = function() {
          if (this.unsubscribeDropTarget) {
            this.unsubscribeDropTarget();
            this.unsubscribeDropTarget = void 0;
          }
        };
        Object.defineProperty(TargetConnector2.prototype, "dropTarget", {
          get: function() {
            return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
          },
          enumerable: true,
          configurable: true
        });
        return TargetConnector2;
      }()
    );
    exports.default = TargetConnector;
  }
});

// node_modules/react-dnd/lib/cjs/DropTarget.js
var require_DropTarget = __commonJS({
  "node_modules/react-dnd/lib/cjs/DropTarget.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var checkDecoratorArguments_1 = require_checkDecoratorArguments();
    var decorateHandler_1 = require_decorateHandler();
    var registerTarget_1 = require_registerTarget();
    var createTargetFactory_1 = require_createTargetFactory();
    var isValidType_1 = require_isValidType();
    var DropTargetMonitorImpl_1 = require_DropTargetMonitorImpl();
    var TargetConnector_1 = require_TargetConnector();
    var discount_lodash_1 = require_discount_lodash2();
    var invariant = require_browser();
    function DropTarget(type, spec, collect, options) {
      if (options === void 0) {
        options = {};
      }
      checkDecoratorArguments_1.default("DropTarget", "type, spec, collect[, options]", type, spec, collect, options);
      var getType = type;
      if (typeof type !== "function") {
        invariant(isValidType_1.default(type, true), 'Expected "type" provided as the first argument to DropTarget to be a string, an array of strings, or a function that returns either given the current props. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', type);
        getType = function() {
          return type;
        };
      }
      invariant(discount_lodash_1.isPlainObject(spec), 'Expected "spec" provided as the second argument to DropTarget to be a plain object. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', spec);
      var createTarget = createTargetFactory_1.default(spec);
      invariant(typeof collect === "function", 'Expected "collect" provided as the third argument to DropTarget to be a function that returns a plain object of props to inject. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', collect);
      invariant(discount_lodash_1.isPlainObject(options), 'Expected "options" provided as the fourth argument to DropTarget to be a plain object when specified. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', collect);
      return function decorateTarget(DecoratedComponent) {
        return decorateHandler_1.default({
          containerDisplayName: "DropTarget",
          createHandler: createTarget,
          registerHandler: registerTarget_1.default,
          createMonitor: function(manager) {
            return new DropTargetMonitorImpl_1.default(manager);
          },
          createConnector: function(backend) {
            return new TargetConnector_1.default(backend);
          },
          DecoratedComponent,
          getType,
          collect,
          options
        });
      };
    }
    exports.default = DropTarget;
  }
});

// node_modules/react-dnd/lib/cjs/DragPreviewImage.js
var require_DragPreviewImage = __commonJS({
  "node_modules/react-dnd/lib/cjs/DragPreviewImage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var DragPreviewImage = React.memo(function(_a) {
      var connect = _a.connect, src = _a.src;
      if (typeof Image !== "undefined") {
        var img_1 = new Image();
        img_1.src = src;
        img_1.onload = function() {
          return connect(img_1);
        };
      }
      return null;
    });
    DragPreviewImage.displayName = "DragPreviewImage";
    exports.default = DragPreviewImage;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/internal/useCollector.js
var require_useCollector = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/internal/useCollector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shallowEqual = require_shallowequal();
    var react_1 = require_react();
    function useCollector(monitor, collect, onUpdate) {
      var _a = react_1.useState(function() {
        return collect(monitor);
      }), collected = _a[0], setCollected = _a[1];
      var updateCollected = react_1.useCallback(function() {
        var nextValue = collect(monitor);
        if (!shallowEqual(collected, nextValue)) {
          setCollected(nextValue);
          if (onUpdate) {
            onUpdate();
          }
        }
      }, [collected, monitor, onUpdate]);
      return [collected, updateCollected];
    }
    exports.useCollector = useCollector;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/internal/useMonitorOutput.js
var require_useMonitorOutput = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/internal/useMonitorOutput.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var useCollector_1 = require_useCollector();
    function useMonitorOutput(monitor, collect, onCollect) {
      var _a = useCollector_1.useCollector(monitor, collect, onCollect), collected = _a[0], updateCollected = _a[1];
      react_1.useEffect(function subscribeToMonitorStateChange() {
        var handlerId = monitor.getHandlerId();
        if (handlerId == null) {
          return void 0;
        }
        return monitor.subscribeToStateChange(updateCollected, {
          handlerIds: [handlerId]
        });
      }, [monitor, updateCollected]);
      return collected;
    }
    exports.useMonitorOutput = useMonitorOutput;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/internal/useDragDropManager.js
var require_useDragDropManager = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/internal/useDragDropManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var DragDropContext_1 = require_DragDropContext();
    var invariant = require_browser();
    function useDragDropManager() {
      var dragDropManager = react_1.useContext(DragDropContext_1.context).dragDropManager;
      invariant(dragDropManager != null, "Expected drag drop context");
      return dragDropManager;
    }
    exports.useDragDropManager = useDragDropManager;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/internal/drag.js
var require_drag = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/internal/drag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var registerSource_1 = require_registerSource();
    var useDragDropManager_1 = require_useDragDropManager();
    var DragSourceMonitorImpl_1 = require_DragSourceMonitorImpl();
    var SourceConnector_1 = require_SourceConnector();
    var invariant = require_browser();
    function useDragSourceMonitor() {
      var manager = useDragDropManager_1.useDragDropManager();
      var monitor = react_1.useMemo(function() {
        return new DragSourceMonitorImpl_1.default(manager);
      }, [manager]);
      var connector = react_1.useMemo(function() {
        return new SourceConnector_1.default(manager.getBackend());
      }, [
        manager
      ]);
      return [monitor, connector];
    }
    exports.useDragSourceMonitor = useDragSourceMonitor;
    function useDragHandler(spec, monitor, connector) {
      var manager = useDragDropManager_1.useDragDropManager();
      var handler = react_1.useMemo(function() {
        return {
          beginDrag: function() {
            var _a = spec.current, begin = _a.begin, item = _a.item;
            if (begin) {
              var beginResult = begin(monitor);
              invariant(beginResult == null || typeof beginResult === "object", "dragSpec.begin() must either return an object, undefined, or null");
              return beginResult || item || {};
            }
            return item || {};
          },
          canDrag: function() {
            if (typeof spec.current.canDrag === "boolean") {
              return spec.current.canDrag;
            } else if (typeof spec.current.canDrag === "function") {
              return spec.current.canDrag(monitor);
            } else {
              return true;
            }
          },
          isDragging: function(globalMonitor, target) {
            var isDragging = spec.current.isDragging;
            return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
          },
          endDrag: function() {
            var end = spec.current.end;
            if (end) {
              end(monitor.getItem(), monitor);
            }
            connector.reconnect();
          }
        };
      }, []);
      react_1.useEffect(function registerHandler() {
        var _a = registerSource_1.default(spec.current.item.type, handler, manager), handlerId = _a[0], unregister = _a[1];
        monitor.receiveHandlerId(handlerId);
        connector.receiveHandlerId(handlerId);
        return unregister;
      }, []);
    }
    exports.useDragHandler = useDragHandler;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/useDrag.js
var require_useDrag = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/useDrag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var useMonitorOutput_1 = require_useMonitorOutput();
    var drag_1 = require_drag();
    var react_1 = require_react();
    var invariant = require_browser();
    function useDrag(spec) {
      var specRef = react_1.useRef(spec);
      specRef.current = spec;
      invariant(spec.item != null, "item must be defined");
      invariant(spec.item.type != null, "item type must be defined");
      var _a = drag_1.useDragSourceMonitor(), monitor = _a[0], connector = _a[1];
      drag_1.useDragHandler(specRef, monitor, connector);
      var result = useMonitorOutput_1.useMonitorOutput(monitor, specRef.current.collect || function() {
        return {};
      }, function() {
        return connector.reconnect();
      });
      var connectDragSource = react_1.useMemo(function() {
        return connector.hooks.dragSource();
      }, [
        connector
      ]);
      var connectDragPreview = react_1.useMemo(function() {
        return connector.hooks.dragPreview();
      }, [
        connector
      ]);
      react_1.useEffect(function() {
        connector.dragSourceOptions = specRef.current.options || null;
        connector.reconnect();
      }, [connector]);
      react_1.useEffect(function() {
        connector.dragPreviewOptions = specRef.current.previewOptions || null;
        connector.reconnect();
      }, [connector]);
      return [result, connectDragSource, connectDragPreview];
    }
    exports.useDrag = useDrag;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/internal/drop.js
var require_drop2 = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/internal/drop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var registerTarget_1 = require_registerTarget();
    var useDragDropManager_1 = require_useDragDropManager();
    var TargetConnector_1 = require_TargetConnector();
    var DropTargetMonitorImpl_1 = require_DropTargetMonitorImpl();
    function useDropTargetMonitor() {
      var manager = useDragDropManager_1.useDragDropManager();
      var monitor = react_1.useMemo(function() {
        return new DropTargetMonitorImpl_1.default(manager);
      }, [manager]);
      var connector = react_1.useMemo(function() {
        return new TargetConnector_1.default(manager.getBackend());
      }, [
        manager
      ]);
      return [monitor, connector];
    }
    exports.useDropTargetMonitor = useDropTargetMonitor;
    function useDropHandler(spec, monitor, connector) {
      var manager = useDragDropManager_1.useDragDropManager();
      var handler = react_1.useMemo(function() {
        return {
          canDrop: function() {
            var canDrop = spec.current.canDrop;
            return canDrop ? canDrop(monitor.getItem(), monitor) : true;
          },
          hover: function() {
            var hover = spec.current.hover;
            if (hover) {
              hover(monitor.getItem(), monitor);
            }
          },
          drop: function() {
            var drop = spec.current.drop;
            if (drop) {
              return drop(monitor.getItem(), monitor);
            }
          }
        };
      }, [monitor]);
      react_1.useEffect(function registerHandler() {
        var _a = registerTarget_1.default(spec.current.accept, handler, manager), handlerId = _a[0], unregister = _a[1];
        monitor.receiveHandlerId(handlerId);
        connector.receiveHandlerId(handlerId);
        return unregister;
      }, [monitor, connector]);
    }
    exports.useDropHandler = useDropHandler;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/useDrop.js
var require_useDrop = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/useDrop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var useMonitorOutput_1 = require_useMonitorOutput();
    var drop_1 = require_drop2();
    var react_1 = require_react();
    var invariant = require_browser();
    function useDrop(spec) {
      var specRef = react_1.useRef(spec);
      specRef.current = spec;
      invariant(spec.accept != null, "accept must be defined");
      var _a = drop_1.useDropTargetMonitor(), monitor = _a[0], connector = _a[1];
      drop_1.useDropHandler(specRef, monitor, connector);
      var result = useMonitorOutput_1.useMonitorOutput(monitor, specRef.current.collect || function() {
        return {};
      }, function() {
        return connector.reconnect();
      });
      var connectDropTarget = react_1.useMemo(function() {
        return connector.hooks.dropTarget();
      }, [
        connector
      ]);
      react_1.useEffect(function() {
        connector.dropTargetOptions = spec.options || null;
        connector.reconnect();
      }, [spec.options]);
      return [result, connectDropTarget];
    }
    exports.useDrop = useDrop;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/useDragLayer.js
var require_useDragLayer = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/useDragLayer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var useDragDropManager_1 = require_useDragDropManager();
    var useCollector_1 = require_useCollector();
    function useDragLayer(collect) {
      var dragDropManager = useDragDropManager_1.useDragDropManager();
      var monitor = dragDropManager.getMonitor();
      var _a = useCollector_1.useCollector(monitor, collect), collected = _a[0], updateCollected = _a[1];
      react_1.useEffect(function() {
        return monitor.subscribeToOffsetChange(updateCollected);
      });
      react_1.useEffect(function() {
        return monitor.subscribeToStateChange(updateCollected);
      });
      return collected;
    }
    exports.useDragLayer = useDragLayer;
  }
});

// node_modules/react-dnd/lib/cjs/hooks/index.js
var require_hooks = __commonJS({
  "node_modules/react-dnd/lib/cjs/hooks/index.js"(exports) {
    "use strict";
    function __export2(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_useDrag());
    __export2(require_useDrop());
    __export2(require_useDragLayer());
  }
});

// node_modules/react-dnd/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/react-dnd/lib/cjs/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var DragDropContext_1 = require_DragDropContext();
    exports.DragDropContext = DragDropContext_1.DragDropContext;
    exports.DragDropContextProvider = DragDropContext_1.DragDropContextProvider;
    exports.DragDropContextConsumer = DragDropContext_1.Consumer;
    var DragLayer_1 = require_DragLayer();
    exports.DragLayer = DragLayer_1.default;
    var DragSource_1 = require_DragSource();
    exports.DragSource = DragSource_1.default;
    var DropTarget_1 = require_DropTarget();
    exports.DropTarget = DropTarget_1.default;
    var DragPreviewImage_1 = require_DragPreviewImage();
    exports.DragPreviewImage = DragPreviewImage_1.default;
    var hooks_1 = require_hooks();
    exports.useDrag = hooks_1.useDrag;
    exports.useDragLayer = hooks_1.useDragLayer;
    exports.useDrop = hooks_1.useDrop;
  }
});

export {
  require_shallowequal,
  require_cjs2 as require_cjs
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-NWLSHHBZ.js.map
